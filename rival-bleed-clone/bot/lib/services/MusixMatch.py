# generated by datamodel-codegen:
#   filename:  data.json
#   timestamp: 2024-10-10T18:11:00+00:00

from __future__ import annotations
from typing import List, Optional, Union
from pydantic import BaseModel
from playwright.async_api import async_playwright, Request
from asyncio import get_running_loop, sleep
from aiohttp import ClientSession
from discord import Embed
from discord.ext.commands import CommandError
from ..patch.context import Context
from lxml import html
from cashews import cache

cache.setup("mem://")
HEADERS = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"}
PLACEHOLDER = "Search by song title, artist, or lyrics"
URL_QUERY = "https://www.musixmatch.com/ws/1.1/macro.search"

class Header(BaseModel):
    status_code: Optional[int] = None
    execute_time: Optional[float] = None


class TrackNameTranslation(BaseModel):
    language: Optional[str] = None
    translation: Optional[str] = None


class TrackNameTranslationListItem(BaseModel):
    track_name_translation: Optional[TrackNameTranslation] = None


class MusicGenre(BaseModel):
    music_genre_id: Optional[int] = None
    music_genre_parent_id: Optional[int] = None
    music_genre_name: Optional[str] = None
    music_genre_name_extended: Optional[str] = None
    music_genre_vanity: Optional[str] = None


class MusicGenreListItem(BaseModel):
    music_genre: Optional[MusicGenre] = None


class PrimaryGenres(BaseModel):
    music_genre_list: Optional[List[MusicGenreListItem]] = None


class MusicGenreListItem1(BaseModel):
    music_genre: Optional[MusicGenre] = None


class SecondaryGenres(BaseModel):
    music_genre_list: Optional[List[MusicGenreListItem1]] = None


class ArtistNameTranslation(BaseModel):
    language: Optional[str] = None
    translation: Optional[str] = None


class ArtistNameTranslationListItem(BaseModel):
    artist_name_translation: Optional[ArtistNameTranslation] = None


class ArtistAliasListItem(BaseModel):
    artist_alias: Optional[str] = None


class MusicGenreListItem2(BaseModel):
    music_genre: Optional[MusicGenre] = None


class PrimaryGenres1(BaseModel):
    music_genre_list: Optional[List[MusicGenreListItem2]] = None


class MusicGenreListItem3(BaseModel):
    music_genre: Optional[MusicGenre] = None


class SecondaryGenres1(BaseModel):
    music_genre_list: Optional[List[MusicGenreListItem3]] = None


class MusicGenreListItem4(BaseModel):
    music_genre: Optional[MusicGenre] = None


class PrimaryGenres2(BaseModel):
    music_genre_list: Optional[List[MusicGenreListItem4]] = None


class SecondaryGenres2(BaseModel):
    music_genre_list: Optional[List] = None


class ArtistCredits1(BaseModel):
    artist_list: Optional[List] = None


class ExternalIds(BaseModel):
    spotify: Optional[List[str]] = None
    itunes: Optional[List[str]] = None


class Artist1(BaseModel):
    artist_id: Optional[int] = None
    artist_fq_id: Optional[str] = None
    artist_mbid: Optional[str] = None
    artist_name: Optional[str] = None
    artist_name_translation_list: Optional[List] = None
    artist_comment: Optional[str] = None
    artist_country: Optional[str] = None
    artist_alias_list: Optional[List[ArtistAliasListItem]] = None
    artist_rating: Optional[int] = None
    primary_genres: Optional[PrimaryGenres2] = None
    secondary_genres: Optional[SecondaryGenres2] = None
    artist_twitter_url: Optional[str] = None
    artist_website_url: Optional[str] = None
    artist_instagram_url: Optional[str] = None
    artist_tiktok_url: Optional[str] = None
    artist_facebook_url: Optional[str] = None
    artist_youtube_url: Optional[str] = None
    artist_vanity_id: Optional[str] = None
    artist_edit_url: Optional[str] = None
    artist_share_url: Optional[str] = None
    artist_credits: Optional[ArtistCredits1] = None
    restricted: Optional[int] = None
    managed: Optional[int] = None
    updated_time: Optional[str] = None
    external_ids: Optional[ExternalIds] = None
    begin_date_year: Optional[str] = None
    begin_date: Optional[str] = None
    end_date_year: Optional[str] = None
    end_date: Optional[str] = None
    artist_image: Optional[List] = None


class ArtistListItem(BaseModel):
    artist: Optional[Artist1] = None


class ArtistCredits(BaseModel):
    artist_list: Optional[List[ArtistListItem]] = None


class ImageFormat(BaseModel):
    image_url: Optional[str] = None
    image_format_id: Optional[int] = None
    width: Optional[int] = None
    height: Optional[int] = None


class ImageFormatListItem(BaseModel):
    image_format: Optional[ImageFormat] = None


class Image(BaseModel):
    image_id: Optional[int] = None
    image_source_id: Optional[int] = None
    image_author: Optional[str] = None
    image_copyright: Optional[str] = None
    image_tags: Optional[str] = None
    image_format_list: Optional[List[ImageFormatListItem]] = None


class ArtistImage(BaseModel):
    image: Optional[Image] = None


class Artist(BaseModel):
    artist_id: Optional[int] = None
    artist_fq_id: Optional[str] = None
    artist_mbid: Optional[str] = None
    artist_name: Optional[str] = None
    artist_name_translation_list: Optional[List[ArtistNameTranslationListItem]] = None
    artist_comment: Optional[str] = None
    artist_country: Optional[str] = None
    artist_alias_list: Optional[List[ArtistAliasListItem]] = None
    artist_rating: Optional[int] = None
    primary_genres: Optional[PrimaryGenres1] = None
    secondary_genres: Optional[SecondaryGenres1] = None
    artist_twitter_url: Optional[str] = None
    artist_website_url: Optional[str] = None
    artist_instagram_url: Optional[str] = None
    artist_tiktok_url: Optional[str] = None
    artist_facebook_url: Optional[str] = None
    artist_youtube_url: Optional[str] = None
    artist_vanity_id: Optional[str] = None
    artist_edit_url: Optional[str] = None
    artist_share_url: Optional[str] = None
    artist_credits: Optional[ArtistCredits] = None
    restricted: Optional[int] = None
    managed: Optional[int] = None
    updated_time: Optional[str] = None
    external_ids: Optional[ExternalIds] = None
    begin_date_year: Optional[str] = None
    begin_date: Optional[str] = None
    end_date_year: Optional[str] = None
    end_date: Optional[str] = None
    artist_image: Optional[Union[List, ArtistImage]] = None


class Track(BaseModel):
    track_id: Optional[int] = None
    track_mbid: Optional[str] = None
    track_isrc: Optional[str] = None
    commontrack_isrcs: Optional[List[List[str]]] = None
    track_spotify_id: Optional[str] = None
    commontrack_spotify_ids: Optional[List[str]] = None
    commontrack_itunes_ids: Optional[List[int]] = None
    track_soundcloud_id: Optional[int] = None
    track_xboxmusic_id: Optional[str] = None
    track_name: Optional[str] = None
    track_name_translation_list: Optional[List[TrackNameTranslationListItem]] = None
    track_rating: Optional[int] = None
    track_length: Optional[int] = None
    commontrack_id: Optional[int] = None
    instrumental: Optional[int] = None
    explicit: Optional[int] = None
    has_lyrics: Optional[int] = None
    has_lyrics_crowd: Optional[int] = None
    has_subtitles: Optional[int] = None
    has_richsync: Optional[int] = None
    has_track_structure: Optional[int] = None
    num_favourite: Optional[int] = None
    lyrics_id: Optional[int] = None
    subtitle_id: Optional[int] = None
    album_id: Optional[int] = None
    album_name: Optional[str] = None
    album_vanity_id: Optional[str] = None
    artist_id: Optional[int] = None
    artist_mbid: Optional[str] = None
    artist_name: Optional[str] = None
    album_coverart_100x100: Optional[str] = None
    album_coverart_350x350: Optional[str] = None
    album_coverart_500x500: Optional[str] = None
    album_coverart_800x800: Optional[str] = None
    track_share_url: Optional[str] = None
    track_edit_url: Optional[str] = None
    commontrack_vanity_id: Optional[str] = None
    restricted: Optional[int] = None
    first_release_date: Optional[str] = None
    updated_time: Optional[str] = None
    primary_genres: Optional[PrimaryGenres] = None
    secondary_genres: Optional[SecondaryGenres] = None
    artist: Optional[Artist] = None
    lyrics: Optional[str] = None

    async def get_lyrics(self) -> str:
        async with ClientSession() as session:
            async with session.get(self.track_share_url.split("?", 1)[0], headers = HEADERS) as response:
                data = await response.text()
        tree = html.fromstring(data)
        lyrics = tree.xpath('//*[@id="__next"]/div/div/div/div[1]/div/div[1]/div[1]/div[2]/div/div/div[2]/div[1]/div[not(@style)]//*[not(@style)]/text()')
        parts = tree.xpath('//*[@id="__next"]/div/div/div/div[1]/div/div[1]/div[1]/div[2]/div/div/div[2]/div[1]/div[not(@style)]//h3/text()')
        string = ""
        for lyric in lyrics:
            if lyric in parts:
                string+="\n"
            else:
                string+=f"{lyric}\n"
        self.lyrics = string
        return str




class TrackListItem(BaseModel):
    track: Optional[Track] = None


class MusicGenreListItem5(BaseModel):
    music_genre: Optional[MusicGenre] = None


class PrimaryGenres3(BaseModel):
    music_genre_list: Optional[List[MusicGenreListItem5]] = None


class MusicGenreListItem6(BaseModel):
    music_genre: Optional[MusicGenre] = None


class SecondaryGenres3(BaseModel):
    music_genre_list: Optional[List[MusicGenreListItem6]] = None


class ArtistCredits2(BaseModel):
    artist_list: Optional[List] = None


class ExternalIds2(BaseModel):
    itunes: Optional[List[str]] = None
    spotify: Optional[List[str]] = None


class Artist2(BaseModel):
    artist_id: Optional[int] = None
    artist_fq_id: Optional[str] = None
    artist_mbid: None = None
    artist_name: Optional[str] = None
    artist_name_translation_list: Optional[List] = None
    artist_comment: Optional[str] = None
    artist_country: Optional[str] = None
    artist_alias_list: Optional[List] = None
    artist_rating: Optional[int] = None
    primary_genres: Optional[PrimaryGenres3] = None
    secondary_genres: Optional[SecondaryGenres3] = None
    artist_twitter_url: Optional[str] = None
    artist_website_url: Optional[str] = None
    artist_instagram_url: Optional[str] = None
    artist_tiktok_url: Optional[str] = None
    artist_facebook_url: Optional[str] = None
    artist_youtube_url: Optional[str] = None
    artist_vanity_id: Optional[str] = None
    artist_edit_url: Optional[str] = None
    artist_share_url: Optional[str] = None
    artist_credits: Optional[ArtistCredits2] = None
    restricted: Optional[int] = None
    managed: Optional[int] = None
    updated_time: Optional[str] = None
    external_ids: Optional[ExternalIds2] = None
    begin_date_year: Optional[str] = None
    begin_date: Optional[str] = None
    end_date_year: Optional[str] = None
    end_date: Optional[str] = None
    artist_image: Optional[List] = None


class ArtistListItem1(BaseModel):
    artist: Optional[Artist2] = None


class BestMatch(BaseModel):
    type: Optional[str] = None
    id: Optional[int] = None


class MacroResultList(BaseModel):
    track_list: Optional[List[TrackListItem]] = None
    artist_list: Optional[List[ArtistListItem1]] = None
    best_match: Optional[BestMatch] = None


class Body(BaseModel):
    macro_result_list: Optional[MacroResultList] = None


class Message(BaseModel):
    header: Optional[Header] = None
    body: Optional[Body] = None


class MusixMatchResponse(BaseModel):
    message: Optional[Message] = None

    async def prepare(self, amount: Optional[int] = 2) -> bool:
        i = 0
        for track in self.message.body.macro_result_list.track_list:
            await track.track.get_lyrics()
            i+=1
            if i == amount:
                break
        return True


@cache(ttl = "30m", key = "lyrics:{query}")
async def get_lyrics(query: str) -> MusixMatchResponse:
    loop = get_running_loop()
    future = loop.create_future()
    async def on_request(r: Request):
        if URL_QUERY in r.url:
            data = await (await r.response()).body()
            future.set_result(data)
            print(r.url)

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page()
        page.on("request", on_request)
        await page.goto("https://musixmatch.com/search")
        await page.get_by_placeholder(PLACEHOLDER).fill(query)
        await page.keyboard.press("Enter")
        while not future.done():
            await sleep(0.01)
        try:
            await browser.close()
            await p.stop()
        except Exception:
            pass
    data = future.result()
    return MusixMatchResponse.parse_raw(data)

async def lyrics_command(ctx: Context, query: str):
    message = await ctx.send(embed = Embed(color = ctx.bot.color, description = f"🔎 {ctx.author.mention}: Searching for `{query[:25]}`"))
    response = await get_lyrics(query)
    await response.prepare()
    embeds = []
    if len(response.message.body.macro_result_list.track_list) > 1:
        for i in [1, 2]:
            track = response.message.body.macro_result_list.track_list[i-1].track
            embeds.append(Embed(color = ctx.bot.color, title = f"{track.artist_name} - {track.track_name}", url = track.track_share_url, description = track.lyrics).set_author(name = ctx.author.display_name, icon_url = ctx.author.display_avatar.url).set_footer(text = f"{track.album_name} ∙ Musixmatch ∙ Page {i}/2", icon_url = "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e3/Musixmatch_logo_icon_only.svg/2089px-Musixmatch_logo_icon_only.svg.png"))
    elif len(response.message.body.macro_result_list.track_list) == 1:
        track = response.message.body.macro_result_list.track_list[0].track
        embeds.append(Embed(color = ctx.bot.color, title = f"{track.artist_name} - {track.tracK_name}", url = track.track_share_url, description = track.lyrics).set_author(name = ctx.author.display_name, icon_url = ctx.author.display_avatar.url).set_footer(text = f"{track.album_name} ∙ Musixmatch ∙ Page 1/1", icon_url = "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e3/Musixmatch_logo_icon_only.svg/2089px-Musixmatch_logo_icon_only.svg.png"))
    else:
        raise CommandError(f"No lyrics found for `{query[:20]}`")
    return await ctx.alternative_paginate(embeds, message)