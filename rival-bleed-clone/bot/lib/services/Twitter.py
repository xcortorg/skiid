# generated by datamodel-codegen:
#   filename:  tw.json
#   timestamp: 2024-07-04T00:05:16+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional
from aiohttp import ClientSession
from io import BytesIO
from discord import Message, Embed, File, Color, Client
from pydantic import BaseModel, Field
from var.config import CONFIG

import re
import json


class MediaItem(BaseModel):
    display_url: Optional[str] = None
    expanded_url: Optional[str] = None
    indices: Optional[List[int]] = None
    url: Optional[str] = None


class Entities(BaseModel):
    hashtags: Optional[List] = None
    urls: Optional[List] = None
    user_mentions: Optional[List] = None
    symbols: Optional[List] = None
    media: Optional[List[MediaItem]] = None


class User(BaseModel):
    id_str: Optional[str] = None
    name: Optional[str] = None
    profile_image_url_https: Optional[str] = None
    screen_name: Optional[str] = None
    verified: Optional[bool] = None
    is_blue_verified: Optional[bool] = None
    profile_image_shape: Optional[str] = None


class EditControl(BaseModel):
    edit_tweet_ids: Optional[List[str]] = None
    editable_until_msecs: Optional[str] = None
    is_edit_eligible: Optional[bool] = None
    edits_remaining: Optional[str] = None


class ExtMediaAvailability(BaseModel):
    status: Optional[str] = None


class FocusRect(BaseModel):
    x: Optional[int] = None
    y: Optional[int] = None
    w: Optional[int] = None
    h: Optional[int] = None


class OriginalInfo(BaseModel):
    height: Optional[int] = None
    width: Optional[int] = None
    focus_rects: Optional[List[FocusRect]] = None


class Large(BaseModel):
    h: Optional[int] = None
    resize: Optional[str] = None
    w: Optional[int] = None


class Medium(BaseModel):
    h: Optional[int] = None
    resize: Optional[str] = None
    w: Optional[int] = None


class Small(BaseModel):
    h: Optional[int] = None
    resize: Optional[str] = None
    w: Optional[int] = None


class Thumb(BaseModel):
    h: Optional[int] = None
    resize: Optional[str] = None
    w: Optional[int] = None


class Sizes(BaseModel):
    large: Optional[Large] = None
    medium: Optional[Medium] = None
    small: Optional[Small] = None
    thumb: Optional[Thumb] = None


class MediaDetail(BaseModel):
    display_url: Optional[str] = None
    expanded_url: Optional[str] = None
    ext_media_availability: Optional[ExtMediaAvailability] = None
    indices: Optional[List[int]] = None
    media_url_https: Optional[str] = None
    original_info: Optional[OriginalInfo] = None
    sizes: Optional[Sizes] = None
    type: Optional[str] = None
    url: Optional[str] = None


class BackgroundColor(BaseModel):
    red: Optional[int] = None
    green: Optional[int] = None
    blue: Optional[int] = None


class CropCandidate(BaseModel):
    x: Optional[int] = None
    y: Optional[int] = None
    w: Optional[int] = None
    h: Optional[int] = None


class Photo(BaseModel):
    backgroundColor: Optional[BackgroundColor] = None
    cropCandidates: Optional[List[CropCandidate]] = None
    expandedUrl: Optional[str] = None
    url: Optional[str] = None
    width: Optional[int] = None
    height: Optional[int] = None


class MediaAvailability(BaseModel):
    status: Optional[str] = None


class Variant(BaseModel):
    type: Optional[str] = None
    src: Optional[str] = None


class VideoId(BaseModel):
    type: Optional[str] = None
    id: Optional[str] = None


class Audience(BaseModel):
    name: Optional[str] = None


class Device(BaseModel):
    name: Optional[str] = None
    version: Optional[str] = None


class Platform(BaseModel):
    audience: Optional[Audience] = None
    device: Optional[Device] = None


class CardPlatform(BaseModel):
    platform: Optional[Platform] = None


class UnifiedCard(BaseModel):
    string_value: Optional[str] = None
    type: Optional[str] = None


class CardUrl(BaseModel):
    scribe_key: Optional[str] = None
    string_value: Optional[str] = None
    type: Optional[str] = None


class BindingValues(BaseModel):
    unified_card: Optional[UnifiedCard] = None
    card_url: Optional[CardUrl] = None


class Card(BaseModel):
    card_platform: Optional[CardPlatform] = None
    name: Optional[str] = None
    url: Optional[str] = None
    binding_values: Optional[BindingValues] = None


class Video(BaseModel):
    aspectRatio: Optional[List[int]] = None
    contentType: Optional[str] = None
    durationMs: Optional[int] = None
    mediaAvailability: Optional[MediaAvailability] = None
    poster: Optional[str] = None
    variants: Optional[List[Variant]] = None
    videoId: Optional[VideoId] = None
    viewCount: Optional[int] = None


class Tweet(BaseModel):
    field__typename: Optional[str] = Field(None, alias="__typename")
    lang: Optional[str] = None
    favorite_count: Optional[int] = None
    possibly_sensitive: Optional[bool] = None
    created_at: Optional[str] = None
    display_text_range: Optional[List[int]] = None
    entities: Optional[Entities] = None
    id_str: Optional[str] = None
    text: Optional[str] = None
    user: Optional[User] = None
    edit_control: Optional[EditControl] = None
    mediaDetails: Optional[List[MediaDetail]] = None
    photos: Optional[List[Photo]] = None
    video: Optional[Video] = None
    conversation_count: Optional[int] = None
    news_action_type: Optional[str] = None
    card: Optional[Card] = None
    isEdited: Optional[bool] = None
    isStaleEdit: Optional[bool] = None

    async def to_message(self, message: Message):
        data = [None, None]
        _url = None
        embed = Embed(
            color=Color.dark_embed(),
            description=f"{CONFIG['emojis']['twitter']} {self.text}",
        )
        embed.set_author(
            name=self.user.name, icon_url=self.user.profile_image_url_https
        )
        try:
            if self.photos:
                embed.set_image(url=self.photos[0].url)
                data[0] = None
            else:
                try:
                    if self.card.binding_values.unified_card.string_value:
                        d = json.loads(
                            self.card.binding_values.unified_card.string_value
                        )
                        for e, entity in d.get("media_entities", {}).items():
                            if video_info := entity.get("video_info"):
                                for v in video_info["variants"]:
                                    if v["content_type"] == "video/mp4":
                                        _url = v["url"]
                except Exception:
                    pass
                url = (
                    _url
                    or [v for v in self.video.variants if v.type == "video/mp4"][0].src
                )
                async with ClientSession() as session:
                    async with session.get(url) as resp:
                        file = File(
                            fp=BytesIO(await resp.read()), filename="twitter.mp4"
                        )
                        data[0] = file
            data[1] = embed
        except Exception as e:
            if message.author.name == "aiohttp":
                raise e
            return await message.channel.send(
                embed=Embed(
                    color=Color.dark_embed(),
                    description="there's no **MEDIA** in that post",
                )
            )
        await message.delete()
        return await message.channel.send(embed=data[1], file=data[0])


async def from_id(tweet_id: int, raw: Optional[bool] = False):
    async with ClientSession() as session:
        async with session.get(
            "https://cdn.syndication.twimg.com/tweet-result",
            params={"id": tweet_id, "lang": "en", "token": "4ds4bk3f3r"},
            # headers={":authority": "cdn.syndication.twimg.com", ":method": "GET", ":path": "/tweet-result?id=1808560117149020409&lang=en&token=4ds4bk3f3r", ":scheme": "https", "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8", "accept-encoding": "gzip, deflate, br, zstd", "accept-language": "en-US,en;q=0.8", "cache-control": "no-cache", "pragma": "no-cache", "priority": "u=0, i", "sec-ch-ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Brave\";v=\"126\"", "sec-ch-ua-mobile": "?1", "sec-ch-ua-platform": "\"Android\"", "sec-fetch-dest": "document", "sec-fetch-mode": "navigate", "sec-fetch-site": "none", "sec-fetch-user": "?1", "sec-gpc": "1", "upgrade-insecure-requests": "1", "user-agent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Mobile Safari/537.36"}
        ) as response:
            data = await response.read()
            data = json.loads(data)
            if raw:
                return data
    return Tweet(**data)

TWITTER_REGEX = re.compile(r"\b(?:https?:\/\/)?(?:www\.)?(?:twitter\.com|x\.com)\b\/status\/(\d+)")

def repost(bot: Client, message: Message):
    if not (match := TWITTER_REGEX.search(message.content)):
        return
    bot.dispatch("twitter_repost", message, match.string)
